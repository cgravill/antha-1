package parquet

import (
	"reflect"
	"strconv"
	"strings"

	"github.com/antha-lang/antha/data"
	"github.com/pkg/errors"
	"github.com/xitongsys/parquet-go/parquet"
)

// creates a dynamic struct type by a Table schema read from Parquet file
func rowStructFromSchema(schema *data.Schema) (reflect.Type, error) {
	if len(schema.Columns) == 0 {
		return nil, errors.New("Empty schema")
	}

	// creating fields
	fields := make([]reflect.StructField, len(schema.Columns))
	for i := range schema.Columns {
		field, err := newRowField(schema.Columns[i], i)
		if err != nil {
			return nil, err
		}
		fields[i] = *field
	}

	// creating dynamic struct
	return reflect.StructOf(fields), nil
}

// creates a dynamic struct field corresponding to the column
func newRowField(column data.Column, index int) (*reflect.StructField, error) {
	// field tag
	tag, err := rowFieldTag(column)
	if err != nil {
		return nil, err
	}

	return &reflect.StructField{
		Name: "Field" + strconv.Itoa(index), // field name: for now, using just generated names (in order to avoid clashes)
		Type: reflect.PtrTo(column.Type),    // field type: using .PtrTo(), because currently all types are considered nullable
		Tag:  tag,
	}, nil
}

// creates parquet tag for a dynamic struct field
func rowFieldTag(column data.Column) (reflect.StructTag, error) {
	// parquet tag builder
	tagBuilder := newParquetTagBuilder()
	// name parquet tag
	tagBuilder.addName(string(column.Name))

	// https://github.com/xitongsys/parquet-go#type
	switch column.Type {
	case reflect.TypeOf(false):
		tagBuilder.addType("BOOLEAN")
	case reflect.TypeOf(int8(0)), reflect.TypeOf(int16(0)), reflect.TypeOf(int32(0)):
		tagBuilder.addType("INT32")
	case reflect.TypeOf(int(0)), reflect.TypeOf(int64(0)):
		tagBuilder.addType("INT64")
	case reflect.TypeOf(float32(0)):
		tagBuilder.addType("FLOAT")
	case reflect.TypeOf(float64(0)):
		tagBuilder.addType("DOUBLE")
	case reflect.TypeOf(""):
		tagBuilder.addType("UTF8").addEncoding("PLAIN_DICTIONARY")
	case reflect.TypeOf(data.TimeMillis(0)):
		tagBuilder.addType("TIME_MILLIS")
	case reflect.TypeOf(data.TimeMicros(0)):
		tagBuilder.addType("TIME_MICROS")
	case reflect.TypeOf(data.TimestampMillis(0)):
		tagBuilder.addType("TIMESTAMP_MILLIS")
	case reflect.TypeOf(data.TimestampMicros(0)):
		tagBuilder.addType("TIMESTAMP_MICROS")
	default:
		return reflect.StructTag(""), errors.Errorf("data type %v is not supported", column.Type)
	}

	// finishing field parquet tag
	return tagBuilder.build(), nil
}

// a tool for building struct tags readable by Parquet reader/writer
type parquetTagBuilder struct {
	builder    strings.Builder
	paramCount int
}

func newParquetTagBuilder() *parquetTagBuilder {
	return new(parquetTagBuilder).add(`parquet:"`)
}

func (b *parquetTagBuilder) addName(value string) *parquetTagBuilder {
	return b.addParam("name", value)
}

func (b *parquetTagBuilder) addType(value string) *parquetTagBuilder {
	return b.addParam("type", value)
}

func (b *parquetTagBuilder) addEncoding(value string) *parquetTagBuilder {
	return b.addParam("encoding", value)
}

func (b *parquetTagBuilder) add(s string) *parquetTagBuilder {
	if _, err := b.builder.WriteString(s); err != nil {
		panic(err)
	}
	return b
}

func (b *parquetTagBuilder) addParam(name string, value string) *parquetTagBuilder {
	if b.paramCount > 0 {
		b.add(", ")
	}
	b.paramCount++
	b.add(name)
	b.add("=")
	b.add(value)
	return b
}

func (b *parquetTagBuilder) build() reflect.StructTag {
	b.add(`"`)
	return reflect.StructTag(b.builder.String())
}

// transforming Parquet file metadata into data.Schema
func schemaFromParquetMetadata(metadata *parquet.FileMetaData) (*data.Schema, error) {
	// currently using Parquet schema only; in fututre we might store something useful in metadata.KeyValueMetadata
	schema := metadata.Schema
	if len(schema) == 0 {
		return nil, errors.New("Empty schema")
	}

	// for now, we can handle schemas only generated by ourselves (i.e. with the aid of parquet-go); such schemas consist of:
	// 1) root element
	if schema[0].Name != "parquet_go_root" {
		return nil, errors.Errorf("Unknown root element: %s", schema[0].Name)
	}

	// 2) list of other elements, each of them corresponds to one column
	columns := make([]data.Column, 0, len(schema))
	for i := 1; i < len(schema); i++ {
		columnType, err := columnTypeFromSchemaElement(schema[i])
		if err != nil {
			return nil, err
		}
		columns = append(columns, data.Column{
			Name: data.ColumnName(schema[i].Name),
			Type: columnType,
		})
	}

	return data.NewSchema(columns), nil
}

// determines Go type to store values from Parquet column defined by schema element
func columnTypeFromSchemaElement(schemaElement *parquet.SchemaElement) (reflect.Type, error) {
	// supporting:
	// 1) optional fields only (=> all generated struct fields will be pointers)
	if schemaElement.GetRepetitionType() != parquet.FieldRepetitionType_OPTIONAL {
		return nil, errors.Errorf("Unsupported: schema element '%s' has repitition type '%s'", schemaElement.Name, schemaElement.GetRepetitionType().String())
	}
	// 2) plain types only
	if schemaElement.NumChildren != nil {
		return nil, errors.Errorf("Unsupported: schema element '%s' has children", schemaElement.Name)
	}

	switch schemaElement.GetType() {
	case parquet.Type_BOOLEAN:
		// boolean
		return reflect.TypeOf(false), nil
	case parquet.Type_INT32:
		// int32 or time32
		if schemaElement.ConvertedType == nil {
			return reflect.TypeOf(int32(0)), nil
		}
		switch *schemaElement.ConvertedType {
		case parquet.ConvertedType_TIME_MILLIS:
			return reflect.TypeOf(data.TimeMillis(0)), nil
		default:
			return nil, errors.Errorf("Unsupported: int32 schema element '%s' has converted type '%s'", schemaElement.Name, schemaElement.ConvertedType.String())
		}
	case parquet.Type_INT64:
		// int64, time64 or timestamp32/64
		if schemaElement.ConvertedType == nil {
			return reflect.TypeOf(int64(0)), nil
		}
		switch *schemaElement.ConvertedType {
		case parquet.ConvertedType_TIME_MICROS:
			return reflect.TypeOf(data.TimeMicros(0)), nil
		case parquet.ConvertedType_TIMESTAMP_MILLIS:
			return reflect.TypeOf(data.TimestampMillis(0)), nil
		case parquet.ConvertedType_TIMESTAMP_MICROS:
			return reflect.TypeOf(data.TimestampMicros(0)), nil
		default:
			return nil, errors.Errorf("Unsupported: int64 schema element '%s' has converted type '%s'", schemaElement.Name, schemaElement.ConvertedType.String())
		}
	case parquet.Type_FLOAT:
		// float32
		return reflect.TypeOf(float32(0)), nil
	case parquet.Type_DOUBLE:
		// float64
		return reflect.TypeOf(float64(0)), nil
	case parquet.Type_BYTE_ARRAY:
		// string
		if schemaElement.ConvertedType == nil {
			return nil, errors.Errorf("Unsupported: byte array schema element '%s' has converted type 'nil'", schemaElement.Name)
		}
		switch *schemaElement.ConvertedType {
		case parquet.ConvertedType_UTF8:
			return reflect.TypeOf(""), nil
		default:
			return nil, errors.Errorf("Unsupported: byte array schema element '%s' has converted type '%s'", schemaElement.Name, schemaElement.ConvertedType.String())
		}
	default:
		return nil, errors.Errorf("Unsupported: schema element '%s' has type '%s'", schemaElement.Name, schemaElement.GetType().String())
	}
}
