// Code generated by gen.py. DO NOT EDIT.
package data

import (
	"reflect"
)
/*
 * 'iter<Type'> are iterator specializations for potentially no-copy, boxed values.
 *
 * The 'as<Type>' types are fallbacks for when the underlying series is dynamic.
 */



//TODO codegen below this point

type BoxFloat64 interface {
	Float64() (float64, bool) // returns false = nil
}

type iterFloat64 interface {
	advanceable
	BoxFloat64
}

// iterateFloat64 is fallback to convert dynamic series to static iterator type
func (s *Series) iterateFloat64(iter iterator) (iterFloat64, error) {
	if cast, ok := iter.(iterFloat64); ok {
		return cast, nil
	}
	if err := s.assignableTo(reflect.TypeOf(float64(0))); err != nil {
		return nil, err
	}
	return &asFloat64{iterator: iter}, nil
}

type asFloat64 struct {
	iterator
}

func (a *asFloat64) Float64() (float64, bool) {
	v := a.iterator.Value()
	if v == nil {
		return float64(0), false
	}
	return v.(float64), true
}


//TODO codegen below this point

type BoxInt64 interface {
	Int64() (int64, bool) // returns false = nil
}

type iterInt64 interface {
	advanceable
	BoxInt64
}

// iterateInt64 is fallback to convert dynamic series to static iterator type
func (s *Series) iterateInt64(iter iterator) (iterInt64, error) {
	if cast, ok := iter.(iterInt64); ok {
		return cast, nil
	}
	if err := s.assignableTo(reflect.TypeOf(int64(0))); err != nil {
		return nil, err
	}
	return &asInt64{iterator: iter}, nil
}

type asInt64 struct {
	iterator
}

func (a *asInt64) Int64() (int64, bool) {
	v := a.iterator.Value()
	if v == nil {
		return int64(0), false
	}
	return v.(int64), true
}


//TODO codegen below this point

type BoxString interface {
	String() (string, bool) // returns false = nil
}

type iterString interface {
	advanceable
	BoxString
}

// iterateString is fallback to convert dynamic series to static iterator type
func (s *Series) iterateString(iter iterator) (iterString, error) {
	if cast, ok := iter.(iterString); ok {
		return cast, nil
	}
	if err := s.assignableTo(reflect.TypeOf("")); err != nil {
		return nil, err
	}
	return &asString{iterator: iter}, nil
}

type asString struct {
	iterator
}

func (a *asString) String() (string, bool) {
	v := a.iterator.Value()
	if v == nil {
		return "", false
	}
	return v.(string), true
}


//TODO codegen below this point

type BoxBool interface {
	Bool() (bool, bool) // returns false = nil
}

type iterBool interface {
	advanceable
	BoxBool
}

// iterateBool is fallback to convert dynamic series to static iterator type
func (s *Series) iterateBool(iter iterator) (iterBool, error) {
	if cast, ok := iter.(iterBool); ok {
		return cast, nil
	}
	if err := s.assignableTo(reflect.TypeOf(false)); err != nil {
		return nil, err
	}
	return &asBool{iterator: iter}, nil
}

type asBool struct {
	iterator
}

func (a *asBool) Bool() (bool, bool) {
	v := a.iterator.Value()
	if v == nil {
		return false, false
	}
	return v.(bool), true
}
