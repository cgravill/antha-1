// Code generated by gen.py. DO NOT EDIT.
package data

import (
	"reflect"
)
/*
 * 'iter<Type'> are iterator specializations for potentially no-copy, boxed values.
 *
 * The 'as<Type>' types are fallbacks for when the underlying series is dynamic.
 */

// BoxFloat64 represents a nullable float64 value
type BoxFloat64 interface {
	Float64() (float64, bool) // returns false = nil
}

// iterFloat64 iterates over nullable float64 values
type iterFloat64 interface {
	advanceable
	BoxFloat64
}

// iterateFloat64 is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to float64
func (s *Series) iterateFloat64(iter iterator) (iterFloat64, error) {
	if cast, ok := iter.(iterFloat64); ok {
		return cast, nil
	}
	if err := s.assignableTo(reflect.TypeOf(float64(0))); err != nil {
		return nil, err
	}
	return &asFloat64{iterator: iter}, nil
}

type asFloat64 struct {
	iterator
}

func (a *asFloat64) Float64() (float64, bool) {
	v := a.iterator.Value()
	if v == nil {
		return float64(0), false
	}
	return v.(float64), true
}
// BoxInt64 represents a nullable int64 value
type BoxInt64 interface {
	Int64() (int64, bool) // returns false = nil
}

// iterInt64 iterates over nullable int64 values
type iterInt64 interface {
	advanceable
	BoxInt64
}

// iterateInt64 is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to int64
func (s *Series) iterateInt64(iter iterator) (iterInt64, error) {
	if cast, ok := iter.(iterInt64); ok {
		return cast, nil
	}
	if err := s.assignableTo(reflect.TypeOf(int64(0))); err != nil {
		return nil, err
	}
	return &asInt64{iterator: iter}, nil
}

type asInt64 struct {
	iterator
}

func (a *asInt64) Int64() (int64, bool) {
	v := a.iterator.Value()
	if v == nil {
		return int64(0), false
	}
	return v.(int64), true
}
// BoxString represents a nullable string value
type BoxString interface {
	String() (string, bool) // returns false = nil
}

// iterString iterates over nullable string values
type iterString interface {
	advanceable
	BoxString
}

// iterateString is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to string
func (s *Series) iterateString(iter iterator) (iterString, error) {
	if cast, ok := iter.(iterString); ok {
		return cast, nil
	}
	if err := s.assignableTo(reflect.TypeOf("")); err != nil {
		return nil, err
	}
	return &asString{iterator: iter}, nil
}

type asString struct {
	iterator
}

func (a *asString) String() (string, bool) {
	v := a.iterator.Value()
	if v == nil {
		return "", false
	}
	return v.(string), true
}
// BoxBool represents a nullable bool value
type BoxBool interface {
	Bool() (bool, bool) // returns false = nil
}

// iterBool iterates over nullable bool values
type iterBool interface {
	advanceable
	BoxBool
}

// iterateBool is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to bool
func (s *Series) iterateBool(iter iterator) (iterBool, error) {
	if cast, ok := iter.(iterBool); ok {
		return cast, nil
	}
	if err := s.assignableTo(reflect.TypeOf(false)); err != nil {
		return nil, err
	}
	return &asBool{iterator: iter}, nil
}

type asBool struct {
	iterator
}

func (a *asBool) Bool() (bool, bool) {
	v := a.iterator.Value()
	if v == nil {
		return false, false
	}
	return v.(bool), true
}
