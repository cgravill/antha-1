
package data
// Code generated by gen.py. DO NOT EDIT.

import (
	"reflect"
	"github.com/pkg/errors"
)

/*
 * specializations for more efficient Filter operations
 */
// MatchFloat64 implements a filter on float64 columns.
type MatchFloat64 func(...float64) bool

// Float64 matches the named column values as float64 arguments. 
// If any column is nil the filter is automatically false.
// If given any SchemaAssertions, they are called now and may have side effects.
func (o *FilterOn) Float64(fn MatchFloat64, assertions ...SchemaAssertion) (*Table, error) {
	if err := o.checkSchema(reflect.TypeOf(float64(0)), assertions...); err != nil {
		return nil, errors.Wrapf(err, "can't filter %+v with %+v", o.t, fn)
	}
	matchColIndexes := o.matchColIndexes()
	matchRow := func(r Row) bool {
		matchVals := make([]float64, len(o.cols))
		for c, i := range matchColIndexes {
			val := r.Values[c].value
			if val == nil {
				return false
			}
			matchVals[i] = val.(float64)
		}
		return fn(matchVals...)
	}

	return filterTable(matchRow, o.t), nil
}

// Float64 matches the named column values as float64 arguments.
func (o *MustFilterOn) Float64(m MatchFloat64, assertions ...SchemaAssertion) *Table {
	t, err := o.FilterOn.Float64(m, assertions...)
	handle(err)
	return t
}

// MatchInt64 implements a filter on int64 columns.
type MatchInt64 func(...int64) bool

// Int64 matches the named column values as int64 arguments. 
// If any column is nil the filter is automatically false.
// If given any SchemaAssertions, they are called now and may have side effects.
func (o *FilterOn) Int64(fn MatchInt64, assertions ...SchemaAssertion) (*Table, error) {
	if err := o.checkSchema(reflect.TypeOf(int64(0)), assertions...); err != nil {
		return nil, errors.Wrapf(err, "can't filter %+v with %+v", o.t, fn)
	}
	matchColIndexes := o.matchColIndexes()
	matchRow := func(r Row) bool {
		matchVals := make([]int64, len(o.cols))
		for c, i := range matchColIndexes {
			val := r.Values[c].value
			if val == nil {
				return false
			}
			matchVals[i] = val.(int64)
		}
		return fn(matchVals...)
	}

	return filterTable(matchRow, o.t), nil
}

// Int64 matches the named column values as int64 arguments.
func (o *MustFilterOn) Int64(m MatchInt64, assertions ...SchemaAssertion) *Table {
	t, err := o.FilterOn.Int64(m, assertions...)
	handle(err)
	return t
}

// MatchString implements a filter on string columns.
type MatchString func(...string) bool

// String matches the named column values as string arguments. 
// If any column is nil the filter is automatically false.
// If given any SchemaAssertions, they are called now and may have side effects.
func (o *FilterOn) String(fn MatchString, assertions ...SchemaAssertion) (*Table, error) {
	if err := o.checkSchema(reflect.TypeOf(""), assertions...); err != nil {
		return nil, errors.Wrapf(err, "can't filter %+v with %+v", o.t, fn)
	}
	matchColIndexes := o.matchColIndexes()
	matchRow := func(r Row) bool {
		matchVals := make([]string, len(o.cols))
		for c, i := range matchColIndexes {
			val := r.Values[c].value
			if val == nil {
				return false
			}
			matchVals[i] = val.(string)
		}
		return fn(matchVals...)
	}

	return filterTable(matchRow, o.t), nil
}

// String matches the named column values as string arguments.
func (o *MustFilterOn) String(m MatchString, assertions ...SchemaAssertion) *Table {
	t, err := o.FilterOn.String(m, assertions...)
	handle(err)
	return t
}

// MatchBool implements a filter on bool columns.
type MatchBool func(...bool) bool

// Bool matches the named column values as bool arguments. 
// If any column is nil the filter is automatically false.
// If given any SchemaAssertions, they are called now and may have side effects.
func (o *FilterOn) Bool(fn MatchBool, assertions ...SchemaAssertion) (*Table, error) {
	if err := o.checkSchema(reflect.TypeOf(false), assertions...); err != nil {
		return nil, errors.Wrapf(err, "can't filter %+v with %+v", o.t, fn)
	}
	matchColIndexes := o.matchColIndexes()
	matchRow := func(r Row) bool {
		matchVals := make([]bool, len(o.cols))
		for c, i := range matchColIndexes {
			val := r.Values[c].value
			if val == nil {
				return false
			}
			matchVals[i] = val.(bool)
		}
		return fn(matchVals...)
	}

	return filterTable(matchRow, o.t), nil
}

// Bool matches the named column values as bool arguments.
func (o *MustFilterOn) Bool(m MatchBool, assertions ...SchemaAssertion) *Table {
	t, err := o.FilterOn.Bool(m, assertions...)
	handle(err)
	return t
}

