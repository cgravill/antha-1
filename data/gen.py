#!/usr/bin/env python

TYPE_SUPPORT = [
	{'Raw':'float64', 'Type':'Float64', 'Zero':'float64(0)', 'ArrowType':'Float64'},
	{'Raw':'int64', 'Type':'Int64', 'Zero':'int64(0)', 'ArrowType':'Int64'},
	{'Raw':'string', 'Type':'String', 'Zero':'""', 'ArrowType':'String'},
	{'Raw':'bool', 'Type':'Bool', 'Zero':'false', 'ArrowType':'Boolean'},
]

CUSTOM_COMPARE = ['string', 'bool']

TPL = {}

TPL['series.gen.go'] = r'''// Code generated by gen.py. DO NOT EDIT.
package data

import (
	"reflect"
)
/*
 * 'iter<Type'> are iterator specializations for potentially no-copy, boxed values.
 *
 * The 'as<Type>' types are fallbacks for when the underlying series is dynamic.
 */

{% for t in env['TYPE_SUPPORT'] %}

// Box{{ t['Type'] }} represents a nullable {{ t['Raw'] }} value
type Box{{ t['Type'] }} interface {
	{{ t['Type'] }}() ({{ t['Raw'] }}, bool) // returns false = nil
}

// iter{{ t['Type'] }} iterates over nullable {{ t['Raw'] }} values
type iter{{ t['Type'] }} interface {
	advanceable
	Box{{ t['Type'] }}
}

// iterate{{ t['Type'] }} is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to {{ t['Raw'] }}
func (s *Series) iterate{{ t['Type'] }}(iter iterator) (iter{{ t['Type'] }}, error) {
	if cast, ok := iter.(iter{{ t['Type'] }}); ok {
		return cast, nil
	}
	if err := s.assignableTo(reflect.TypeOf({{ t['Zero'] }})); err != nil {
		return nil, err
	}
	return &as{{ t['Type'] }}{iterator: iter}, nil
}

type as{{ t['Type'] }} struct {
	iterator
}

func (a *as{{ t['Type'] }}) {{ t['Type'] }}() ({{ t['Raw'] }}, bool) {
	v := a.iterator.Value()
	if v == nil {
		return {{ t['Zero'] }}, false
	}
	return v.({{ t['Raw'] }}), true
}
{% endfor %}
'''

TPL['extend.gen.go']=r'''// Code generated by gen.py. DO NOT EDIT.
package data

import (
	"reflect"
	"github.com/pkg/errors"
)

/*
 * specializations for more efficient Extend operations
 */

{% for t in env['TYPE_SUPPORT'] %}
// {{ t['Type'] }} adds a {{ t['Raw'] }} col using {{ t['Raw'] }} inputs.  Null on any null inputs.
func (e *ExtendOn) {{ t['Type'] }}(f func(v ...{{ t['Raw'] }}) {{ t['Raw'] }}) *Table {
	// TODO move from lazy to eager type validation
	return NewTable(append(e.extension.series, &Series{
		col: e.extension.newCol,
		typ: reflect.TypeOf({{ t['Zero'] }}),
		read: func(cache *seriesIterCache) iterator {
			// Every series must be cast or converted
			colReader := make([]iter{{ t['Type'] }}, len(e.inputs))
			var err error
			for i, ser := range e.inputs {
				iter := cache.Ensure(ser)
				colReader[i], err = ser.iterate{{ t['Type'] }}(iter) // note colReader[i] is not itself in the cache!
				if err != nil {
					// TODO non-panic option?
					// TODO test coverage
					panic(errors.Wrapf(err, "when projecting new column %v", e.extension.newCol))
				}
			}
			// end when table exhausted
			e.extension.extensionSource(cache)
			return &extend{{ t['Type'] }}{f: f, source: colReader}
		}},
	))
}

var _ iter{{ t['Type'] }} = (*extend{{ t['Type'] }})(nil)

type extend{{ t['Type'] }} struct {
	f      func(v ...{{ t['Raw'] }}) {{ t['Raw'] }}
	source []iter{{ t['Type'] }}
}

func (x *extend{{ t['Type'] }}) Next() bool {
	return true
}
func (x *extend{{ t['Type'] }}) Value() interface{} {
	v, ok := x.{{ t['Type'] }}()
	if !ok {
		return nil
	}
	return v
}
func (x *extend{{ t['Type'] }}) {{ t['Type'] }}() ({{ t['Raw'] }}, bool) {
	args := make([]{{ t['Raw'] }}, len(x.source))
	var ok bool
	for i, s := range x.source {
		args[i], ok = s.{{ t['Type'] }}()
		if !ok {
			return {{ t['Zero'] }}, false
		}
	}
	v := x.f(args...)
	return v, true
}

{% endfor %}
'''

TPL['arrow.gen.go']=r'''// Code generated by gen.py. DO NOT EDIT.
package data

import (
	"reflect"

	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/memory"
	"github.com/pkg/errors"
)

{% for t in env['TYPE_SUPPORT'] %}

// {{ t['Raw'] }}

func NewArrowSeries{{ t['Type'] }}(col ColumnName, values *array.{{ t['ArrowType'] }}) *Series {
	metadata := &{{ t['Raw'] }}ArrowSeriesMeta{values: values}
	return &Series{
		typ:  reflect.TypeOf({{ t['Zero'] }}),
		col:  col,
		read: metadata.read,
		meta: metadata,
	}
}

func NewArrowSeriesFromSlice{{ t['Type'] }}(col ColumnName, values []{{ t['Raw'] }}, mask []bool) *Series {
	builder := array.New{{ t['ArrowType'] }}Builder(memory.DefaultAllocator)
	if len(values) > 0 {
		builder.AppendValues(values, mask)
	}
	arrowValues := builder.New{{ t['ArrowType'] }}Array()
	return NewArrowSeries{{ t['Type'] }}(col, arrowValues)
}

func NewArrowSeriesFromSeries{{ t['Type'] }}(series *Series) (*Series, error) {
	if !series.meta.IsBounded() {
		return nil, errors.New("Unable to materialize unbounded series")
	}

	iterCache := &seriesIterCache{}
	iter := series.read(iterCache)

	typedIter, err := series.iterate{{ t['Type'] }}(iter)
	if err != nil {
		return nil, err
	}

	builder := array.New{{ t['ArrowType'] }}Builder(memory.DefaultAllocator)
	for typedIter.Next() {
		if value, ok := typedIter.{{ t['Type'] }}(); ok {
			builder.Append(value)
		} else {
			builder.AppendNull()
		}
	}
	arrowValues := builder.New{{ t['ArrowType'] }}Array()
	return NewArrowSeries{{ t['Type'] }}(series.col, arrowValues), nil
}

func NewArrowSeriesFromRows{{ t['Type'] }}(rows *Rows, col ColumnName) (*Series, error) {
	builder := array.New{{ t['ArrowType'] }}Builder(memory.DefaultAllocator)
	for i := range rows.Data {
		observation, err := rows.Data[i].Observation(col)
		if err != nil {
			return nil, err
		}

		if observation.value == nil {
			builder.AppendNull()
		} else if value, ok := observation.value.({{ t['Raw'] }}); ok {
			builder.Append(value)
		} else {
			return nil, errors.Errorf("Observation value %v cannot be castede to {{ t['Raw'] }}", observation.value)
		}
	}
	arrowValues := builder.New{{ t['ArrowType'] }}Array()
	return NewArrowSeries{{ t['Type'] }}(col, arrowValues), nil
}

type {{ t['Raw'] }}ArrowSeriesMeta struct {
	values *array.{{ t['ArrowType'] }}
}

func (m *{{ t['Raw'] }}ArrowSeriesMeta) IsBounded() bool { return true; }
func (m *{{ t['Raw'] }}ArrowSeriesMeta) IsMaterialized() bool { return true; }

func (m *{{ t['Raw'] }}ArrowSeriesMeta) ExactSize() int {
	return m.values.Len()
}
func (m *{{ t['Raw'] }}ArrowSeriesMeta) MaxSize() int {
	return m.values.Len()
}

func (m *{{ t['Raw'] }}ArrowSeriesMeta) read(_ *seriesIterCache) iterator {
	return &{{ t['Raw'] }}ArrowSeriesIter{
		{{ t['Raw'] }}ArrowSeriesMeta: m,
		pos:                  -1,
	}
}

var _ Bounded = (*{{ t['Raw'] }}ArrowSeriesMeta)(nil)

type {{ t['Raw'] }}ArrowSeriesIter struct {
	*{{ t['Raw'] }}ArrowSeriesMeta
	pos int
}

func (i *{{ t['Raw'] }}ArrowSeriesIter) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *{{ t['Raw'] }}ArrowSeriesIter) {{ t['Type'] }}() ({{ t['Raw'] }}, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return {{ t['Zero'] }}, false
	}
}

func (i *{{ t['Raw'] }}ArrowSeriesIter) Value() interface{} {
	if val, ok := i.{{ t['Type'] }}(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*{{ t['Raw'] }}ArrowSeriesIter)(nil)
var _ iter{{ t['Type'] }} = (*{{ t['Raw'] }}ArrowSeriesIter)(nil)

{% endfor %}
'''

TPL['row.gen.go']=r'''// Code generated by gen.py. DO NOT EDIT.
package data

{% for t in env['TYPE_SUPPORT'] %}

// {{ t['Raw'] }}

func (o Observation) Must{{ t['Type'] }}() {{ t['Raw'] }} {
	return o.value.({{ t['Raw'] }})
}

func (o Observation) {{ t['Type'] }}() ({{ t['Raw'] }}, bool) {
	if o.IsNull() {
		return {{ t['Zero'] }}, false
	} else {
		return o.Must{{ t['Type'] }}(), true
	}
}

{% endfor %}
'''

TPL['sort.gen.go']=r'''// Code generated by gen.py. DO NOT EDIT.
package data

import (
	"reflect"

	"github.com/pkg/errors"
)

func createColumnSortFunc(schema Schema, columnKey ColumnKey) (sortFuncExt, error) {
	columnIndex, err := schema.ColIndex(columnKey.Column)
	if err != nil {
		return nil, err
	}

	// TODO: more optimal comparators for non-nullable columns
	switch schema.Columns[columnIndex].Type { {% for t in env['TYPE_SUPPORT'] %}
	case reflect.TypeOf({{ t['Zero'] }}):
		return createColumnSortFunc{{ t['Type'] }}(columnIndex, columnKey.Asc), nil{% endfor %}
	default:
		return nil, errors.New("The data type is not supported, expecting a column of some supported primitive type")
	}
}

{% for t in env['TYPE_SUPPORT'] %}
// {{ t['Raw'] }}

func createColumnSortFunc{{ t['Type'] }}(columnIndex int, asc bool) sortFuncExt {
	order := 1
	if !asc {
		order = -1
	}

	return func(r1 *Row, r2 *Row) int {
		return compareObservations{{ t['Type'] }}(r1.Values[columnIndex], r2.Values[columnIndex]) * order
	}
}

func compareObservations{{ t['Type'] }}(o1, o2 Observation) int {
	val1, notNull1 := o1.{{ t['Type'] }}()
	val2, notNull2 := o2.{{ t['Type'] }}()
	switch {
	case notNull1 && notNull2:
		return compare{{ t['Type'] }}(val1, val2)
	case notNull1 && !notNull2:
		return 1
	case !notNull1 && notNull2:
		return -1
	default:
		return 0
	}
}

{% if t['Raw'] not in env['CUSTOM_COMPARE'] %}
func compare{{ t['Type'] }}(val1, val2 {{ t['Raw'] }}) int {
	switch {
	case val1 < val2:
		return -1
	case val1 > val2:
		return 1
	default:
		return 0
	}
}
{%  endif %}

{% endfor %}
'''

import jinja2
def write_tpl(tpl, name):
	template = jinja2.Template(tpl)
	with open(name, 'wb') as f:
		f.write(template.render(env=globals()))

if __name__ == "__main__":
	for (f, tpl) in TPL.iteritems():
		write_tpl(tpl, f)