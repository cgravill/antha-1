#!/usr/bin/env python

TYPE_SUPPORT = [
	{'Raw':'float64', 'Type':'Float64', 'Zero':'float64(0)'},
	{'Raw':'int64', 'Type':'Int64', 'Zero':'int64(0)'},
	{'Raw':'string', 'Type':'String', 'Zero':'""'},
	{'Raw':'bool', 'Type':'Bool', 'Zero':'false'},
]

TPL = {}

TPL['series.gen.go'] = r'''// Code generated by gen.py. DO NOT EDIT.
package data

import (
	"reflect"
)
/*
 * 'iter<Type'> are iterator specializations for potentially no-copy, boxed values.
 *
 * The 'as<Type>' types are fallbacks for when the underlying series is dynamic.
 */

{% for t in env['TYPE_SUPPORT'] %}

//TODO codegen below this point

type Box{{ t['Type'] }} interface {
	{{ t['Type'] }}() ({{ t['Raw'] }}, bool) // returns false = nil
}

type iter{{ t['Type'] }} interface {
	advanceable
	Box{{ t['Type'] }}
}

// iterate{{ t['Type'] }} is fallback to convert dynamic series to static iterator type
func (s *Series) iterate{{ t['Type'] }}(iter iterator) (iter{{ t['Type'] }}, error) {
	if cast, ok := iter.(iter{{ t['Type'] }}); ok {
		return cast, nil
	}
	if err := s.assignableTo(reflect.TypeOf({{ t['Zero'] }})); err != nil {
		return nil, err
	}
	return &as{{ t['Type'] }}{iterator: iter}, nil
}

type as{{ t['Type'] }} struct {
	iterator
}

func (a *as{{ t['Type'] }}) {{ t['Type'] }}() ({{ t['Raw'] }}, bool) {
	v := a.iterator.Value()
	if v == nil {
		return {{ t['Zero'] }}, false
	}
	return v.({{ t['Raw'] }}), true
}
{% endfor %}
'''

TPL['extend.gen.go']=r'''// Code generated by gen.py. DO NOT EDIT.
package data

import (
	"reflect"
	"github.com/pkg/errors"
)

{% for t in env['TYPE_SUPPORT'] %}

// {{ t['Type'] }} adds a {{ t['Raw'] }} col using {{ t['Raw'] }} inputs.  Null on any null inputs.
func (e *ExtendOn) {{ t['Type'] }}(f func(v ...{{ t['Raw'] }}) {{ t['Raw'] }}) *Table {
	// TODO move from lazy to eager type validation
	return NewTable(append(e.extension.series, &Series{
		col: e.extension.newCol,
		typ: reflect.TypeOf({{ t['Zero'] }}),
		read: func(cache seriesIterCache) iterator {
			// Every series must be cast or converted
			colReader := make([]iter{{ t['Type'] }}, len(e.inputs))
			var err error
			for i, ser := range e.inputs {
				iter := cache.Ensure(ser)
				colReader[i], err = ser.iterate{{ t['Type'] }}(iter) // note colReader[i] is not itself in the cache!
				if err != nil {
					// TODO non-panic option?
					// TODO test coverage
					panic(errors.Wrapf(err, "when projecting new column %v", e.extension.newCol))
				}
			}
			return &extend{{ t['Type'] }}{f: f, source: colReader}
		}},
	))
}

var _ iter{{ t['Type'] }} = (*extend{{ t['Type'] }})(nil)

type extend{{ t['Type'] }} struct {
	f      func(v ...{{ t['Raw'] }}) {{ t['Raw'] }}
	source []iter{{ t['Type'] }}
}

func (x *extend{{ t['Type'] }}) Next() bool {
	return true
}
func (x *extend{{ t['Type'] }}) Value() interface{} {
	v, ok := x.{{ t['Type'] }}()
	if !ok {
		return nil
	}
	return v
}
func (x *extend{{ t['Type'] }}) {{ t['Type'] }}() ({{ t['Raw'] }}, bool) {
	args := make([]{{ t['Raw'] }}, len(x.source))
	var ok bool
	for i, s := range x.source {
		args[i], ok = s.{{ t['Type'] }}()
		if !ok {
			return {{ t['Zero'] }}, false
		}
	}
	v := x.f(args...)
	return v, true
}

{% endfor %}
'''

import jinja2
def write_tpl(tpl, name):
	template = jinja2.Template(tpl)
	with open(name, 'wb') as f:
		f.write(template.render(env=globals()))

if __name__ == "__main__":
	for (f, tpl) in TPL.iteritems():
		write_tpl(tpl, f)