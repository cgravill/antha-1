#!/usr/bin/env python

# types with arrow and native adapter support
TYPE_SUPPORT = [
	{'Raw':'float64', 'Type':'Float64', 'Zero':'float64(0)', 'ArrowType':'Float64'},
	{'Raw':'int64', 'Type':'Int64', 'Zero':'int64(0)', 'ArrowType':'Int64'},
	{'Raw':'string', 'Type':'String', 'Zero':'""', 'ArrowType':'String'},
	{'Raw':'bool', 'Type':'Bool', 'Zero':'false', 'ArrowType':'Boolean'},
]

# additional types for reflection-based ops
TYPE_REFLECT_SUPPORT = [
	{'Raw':'interface{}', 'Type':'Interface'},
]


CUSTOM_COMPARE = ['string', 'bool']

TPL = {}

TPL['series.gen.go'] = r'''
package data
// Code generated by gen.py. DO NOT EDIT.

import (
	"reflect"
)
/*
 * 'iter<Type'> are iterator specializations for potentially no-copy, boxed values.
 *
 * The 'as<Type>' types are fallbacks for when the underlying series is dynamic.
 */

{% for t in env['TYPE_SUPPORT'] -%}

// Box{{ t['Type'] }} represents a nullable {{ t['Raw'] }} value
type Box{{ t['Type'] }} interface {
	{{ t['Type'] }}() ({{ t['Raw'] }}, bool) // returns false = nil
}

// iter{{ t['Type'] }} iterates over nullable {{ t['Raw'] }} values
type iter{{ t['Type'] }} interface {
	advanceable
	Box{{ t['Type'] }}
}

// iterate{{ t['Type'] }} is a fallback to convert dynamic series to static iterator type.
// an error is returned if the series' declared type is not assignable to {{ t['Raw'] }}
func (s *Series) iterate{{ t['Type'] }}(iter iterator) (iter{{ t['Type'] }}, error) {
	if cast, ok := iter.(iter{{ t['Type'] }}); ok {
		return cast, nil
	}
	if err := s.assignableTo(reflect.TypeOf({{ t['Zero'] }})); err != nil {
		return nil, err
	}
	return &as{{ t['Type'] }}{iterator: iter}, nil
}

type as{{ t['Type'] }} struct {
	iterator
}

func (a *as{{ t['Type'] }}) {{ t['Type'] }}() ({{ t['Raw'] }}, bool) {
	v := a.iterator.Value()
	if v == nil {
		return {{ t['Zero'] }}, false
	}
	return v.({{ t['Raw'] }}), true
}
{% endfor %}
'''

TPL['extend.gen.go']=r'''
package data
// Code generated by gen.py. DO NOT EDIT.

import (
	"reflect"
	"github.com/pkg/errors"
)

/*
 * specializations for more efficient Extend operations
 */

{% for t in env['TYPE_SUPPORT'] -%}
// {{ t['Type'] }} adds a {{ t['Raw'] }} col using {{ t['Raw'] }} inputs.  Null on any null inputs.
func (e *ExtendOn) {{ t['Type'] }}(f func(v ...{{ t['Raw'] }}) {{ t['Raw'] }}) *Table {
	// TODO move from lazy to eager type validation
	return NewTable(append(e.extension.series, &Series{
		col: e.extension.newCol,
		typ: reflect.TypeOf({{ t['Zero'] }}),
		read: func(cache *seriesIterCache) iterator {
			// Every series must be cast or converted
			colReader := make([]iter{{ t['Type'] }}, len(e.inputs))
			var err error
			for i, ser := range e.inputs {
				iter := cache.Ensure(ser)
				colReader[i], err = ser.iterate{{ t['Type'] }}(iter) // note colReader[i] is not itself in the cache!
				if err != nil {
					// TODO non-panic option?
					// TODO test coverage
					panic(errors.Wrapf(err, "when projecting new column %v", e.extension.newCol))
				}
			}
			// end when table exhausted
			e.extension.extensionSource(cache)
			return &extend{{ t['Type'] }}{f: f, source: colReader}
		}},
	))
}

var _ iter{{ t['Type'] }} = (*extend{{ t['Type'] }})(nil)

type extend{{ t['Type'] }} struct {
	f      func(v ...{{ t['Raw'] }}) {{ t['Raw'] }}
	source []iter{{ t['Type'] }}
}

func (x *extend{{ t['Type'] }}) Next() bool {
	return true
}
func (x *extend{{ t['Type'] }}) Value() interface{} {
	v, ok := x.{{ t['Type'] }}()
	if !ok {
		return nil
	}
	return v
}
func (x *extend{{ t['Type'] }}) {{ t['Type'] }}() ({{ t['Raw'] }}, bool) {
	args := make([]{{ t['Raw'] }}, len(x.source))
	var ok bool
	for i, s := range x.source {
		args[i], ok = s.{{ t['Type'] }}()
		if !ok {
			return {{ t['Zero'] }}, false
		}
	}
	v := x.f(args...)
	return v, true
}

{% endfor %}
'''

TPL['filter.gen.go']=r'''
package data
// Code generated by gen.py. DO NOT EDIT.

import (
	"reflect"
	"github.com/pkg/errors"
)

/*
 * specializations for more efficient Filter operations
 */
{% for t in env['TYPE_SUPPORT'] + env['TYPE_REFLECT_SUPPORT']   -%}

// Match{{ t['Type'] }} implements a filter on {{ t['Raw'] }} columns.
type Match{{ t['Type'] }} func(...{{ t['Raw'] }}) bool

// {{ t['Type'] }} matches the named column values as {{ t['Raw'] }} arguments.
// If given any SchemaAssertions, they are called now and may have side effects.
func (o *FilterOn) {{ t['Type'] }}(fn Match{{ t['Type'] }}, assertions ...SchemaAssertion) (*Table, error) {
	if err := o.checkSchema({% if 'Zero' in t %}reflect.TypeOf({{ t['Zero'] }}){% else %}nil{% endif %}, assertions...); err != nil {
		return nil, errors.Wrapf(err, "can't filter %+v with %+v", o.t, fn)
	}
	matchColIndexes := o.matchColIndexes()
	matchRow := func(r Row) bool {
		matchVals := make([]{{ t['Raw'] }}, len(o.cols))
		for c, i := range matchColIndexes {
			matchVals[i] = r.Values[c].value.({{ t['Raw'] }})
		}
		return fn(matchVals...)
	}

	return filterTable(matchRow, o.t), nil
}

// {{ t['Type'] }} matches the named column values as {{ t['Raw'] }} arguments.
func (o *MustFilterOn) {{ t['Type'] }}(m Match{{ t['Type'] }}, assertions ...SchemaAssertion) *Table {
	t, err := o.FilterOn.{{ t['Type'] }}(m, assertions...)
	handle(err)
	return t
}

{% endfor %}
'''

TPL['arrow.gen.go']=r'''
package data
// Code generated by gen.py. DO NOT EDIT.

import (
	"reflect"

	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/memory"
	"github.com/pkg/errors"
)

// Series implemented on the top of Apache Arrow.
// For now, designed in the same style as arrow/go library: i.e. no reflection, using generated code supporting a finite list of data types

// NewArrowSeriesBuilder creates a new builder for Arrow Series
func NewArrowSeriesBuilder(col ColumnName, typ reflect.Type) (MaterializedSeriesBuilder, error) {
	switch typ {
		{% for t in env['TYPE_SUPPORT'] -%}
		case reflect.TypeOf({{ t['Zero'] }}):
			return newArrowSeriesBuilder{{ t['Type'] }}(col), nil
		{% endfor -%}
		default:
			return nil, errors.Errorf("The data type %v is not supported", typ)
	}
}

// NewArrowSeries converts an existing Arrow array to a new Series. Only closed list of Arrow data types is supported yet.
func NewArrowSeries(col ColumnName, values array.Interface) (*Series, error) {
	switch typedValues := values.(type) {
	{% for t in env['TYPE_SUPPORT'] -%}
	case *array.{{ t['ArrowType'] }}:
		return NewArrowSeries{{ t['Type'] }}(col, typedValues), nil
	{% endfor -%}
	default:
		return nil, errors.Errorf("Arrow data type %v is not supported", values.DataType().ID())
	}
}

// NewArrowSeriesFromSlice converts a slice of scalars to a new (Arrow-based) Series
// mask denotes elements set to null; it is optional and can be set to nil
// Only a closed list of primitive data types is supported yet
func NewArrowSeriesFromSlice(col ColumnName, values interface{}, mask []bool) (*Series, error) {
	switch typedValues := values.(type) {
	{% for t in env['TYPE_SUPPORT'] -%}
	case []{{ t['Raw'] }}:
		return NewArrowSeriesFromSlice{{ t['Type'] }}(col, typedValues, mask), nil
	{% endfor -%}
	default:
		return nil, errors.Errorf("The data type %v is not supported, expecting slice of supported primitive types", reflect.TypeOf(values))
	}
}

// NewArrowSeriesFromSeries converts arbitrary Series into a new Arrow-based Series
func NewArrowSeriesFromSeries(series *Series) (*Series, error) {
	// for now, only series of supported Arrow types are supported
	switch series.typ {
	{% for t in env['TYPE_SUPPORT'] -%}
	case reflect.TypeOf({{ t['Zero'] }}):
		return NewArrowSeriesFromSeries{{ t['Type'] }}(series)
	{% endfor -%}
	default:
		return nil, errors.New("The data type is not supported, expecting a series of supported primitive type")
	}
}

// NewArrowSeriesFromRows converts a column of a Row-wide representation of a table into a new Arrow-based Series
func NewArrowSeriesFromRows(rows *Rows, col ColumnName) (*Series, error) {
	column, err := rows.Schema.Col(col)
	if err != nil {
		return nil, err
	}

	// for now, only columns of supported Arrow types are supported
	switch column.Type {
	{% for t in env['TYPE_SUPPORT'] -%}
	case reflect.TypeOf({{ t['Zero'] }}):
		return NewArrowSeriesFromRows{{ t['Type'] }}(rows, col)
	{% endfor -%}
	default:
		return nil, errors.New("The data type is not supported, expecting rows of supported primitive type")
	}
}

{% for t in env['TYPE_SUPPORT'] -%}

// {{ t['Raw'] }}

type arrowSeriesBuilder{{ t['Type'] }} struct {
	builder *array.{{ t['ArrowType'] }}Builder
	col ColumnName
}

func newArrowSeriesBuilder{{ t['Type'] }}(col ColumnName) *arrowSeriesBuilder{{ t['Type'] }} {
	return &arrowSeriesBuilder{{ t['Type'] }} {
		builder: array.New{{ t['ArrowType'] }}Builder(memory.DefaultAllocator),
		col:     col,
	}
}

func (b* arrowSeriesBuilder{{ t['Type'] }}) Reserve(capacity int)     { b.builder.Reserve(capacity) }
func (b* arrowSeriesBuilder{{ t['Type'] }}) Size() int                { return b.builder.Len() }
func (b* arrowSeriesBuilder{{ t['Type'] }}) Append(value interface{}) { b.builder.Append(value.({{ t['Raw'] }})) }
func (b* arrowSeriesBuilder{{ t['Type'] }}) AppendNull()              { b.builder.AppendNull() }
func (b* arrowSeriesBuilder{{ t['Type'] }}) Build() *Series           { return NewArrowSeries{{ t['Type'] }}(b.col, b.builder.New{{ t['ArrowType'] }}Array()) }

var _ MaterializedSeriesBuilder = (*arrowSeriesBuilder{{ t['Type'] }})(nil)

func NewArrowSeries{{ t['Type'] }}(col ColumnName, values *array.{{ t['ArrowType'] }}) *Series {
	metadata := &arrowSeriesMeta{values: values}
	return &Series{
		typ:  reflect.TypeOf({{ t['Zero'] }}),
		col:  col,
		read: metadata.read{{ t['Type'] }},
		meta: metadata,
	}
}

func NewArrowSeriesFromSlice{{ t['Type'] }}(col ColumnName, values []{{ t['Raw'] }}, mask []bool) *Series {
	builder := array.New{{ t['ArrowType'] }}Builder(memory.DefaultAllocator)
	if len(values) > 0 {
		builder.AppendValues(values, mask)
	}
	arrowValues := builder.New{{ t['ArrowType'] }}Array()
	return NewArrowSeries{{ t['Type'] }}(col, arrowValues)
}

func NewArrowSeriesFromSeries{{ t['Type'] }}(series *Series) (*Series, error) {
	if !series.meta.IsBounded() {
		return nil, errors.New("Unable to materialize unbounded series")
	}

	iterCache := &seriesIterCache{}
	iter := series.read(iterCache)

	typedIter, err := series.iterate{{ t['Type'] }}(iter)
	if err != nil {
		return nil, err
	}

	builder := array.New{{ t['ArrowType'] }}Builder(memory.DefaultAllocator)
	for typedIter.Next() {
		if value, ok := typedIter.{{ t['Type'] }}(); ok {
			builder.Append(value)
		} else {
			builder.AppendNull()
		}
	}
	arrowValues := builder.New{{ t['ArrowType'] }}Array()
	return NewArrowSeries{{ t['Type'] }}(series.col, arrowValues), nil
}

func NewArrowSeriesFromRows{{ t['Type'] }}(rows *Rows, col ColumnName) (*Series, error) {
	builder := array.New{{ t['ArrowType'] }}Builder(memory.DefaultAllocator)
	for i := range rows.Data {
		observation, err := rows.Data[i].Observation(col)
		if err != nil {
			return nil, err
		}

		if observation.value == nil {
			builder.AppendNull()
		} else if value, ok := observation.value.({{ t['Raw'] }}); ok {
			builder.Append(value)
		} else {
			return nil, errors.Errorf("Observation value %v cannot be castede to {{ t['Raw'] }}", observation.value)
		}
	}
	arrowValues := builder.New{{ t['ArrowType'] }}Array()
	return NewArrowSeries{{ t['Type'] }}(col, arrowValues), nil
}

func (m *arrowSeriesMeta) read{{ t['Type'] }}(_ *seriesIterCache) iterator {
	return &arrowSeriesIter{{ t['Type'] }}{
		values: m.values.(*array.{{ t['ArrowType'] }}),
		pos:    -1,
	}
}

type arrowSeriesIter{{ t['Type'] }} struct {
	values *array.{{ t['ArrowType'] }}
	pos int
}

func (i *arrowSeriesIter{{ t['Type'] }}) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *arrowSeriesIter{{ t['Type'] }}) {{ t['Type'] }}() ({{ t['Raw'] }}, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return {{ t['Zero'] }}, false
	}
}

func (i *arrowSeriesIter{{ t['Type'] }}) Value() interface{} {
	if val, ok := i.{{ t['Type'] }}(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*arrowSeriesIter{{ t['Type'] }})(nil)
var _ iter{{ t['Type'] }} = (*arrowSeriesIter{{ t['Type'] }})(nil)

{% endfor %}
'''

TPL['row.gen.go']=r'''
package data
// Code generated by gen.py. DO NOT EDIT.

{% for t in env['TYPE_SUPPORT'] -%}

// {{ t['Raw'] }}

func (o Observation) Must{{ t['Type'] }}() {{ t['Raw'] }} {
	return o.value.({{ t['Raw'] }})
}

func (o Observation) {{ t['Type'] }}() ({{ t['Raw'] }}, bool) {
	if o.IsNull() {
		return {{ t['Zero'] }}, false
	} else {
		return o.Must{{ t['Type'] }}(), true
	}
}

{% endfor %}
'''

TPL['sort.gen.go']=r'''
package data
// Code generated by gen.py. DO NOT EDIT.

import (
	"reflect"

	"github.com/pkg/errors"
)

func createColumnSortFunc(schema Schema, columnKey ColumnKey) (sortFuncExt, error) {
	columnIndex, err := schema.ColIndex(columnKey.Column)
	if err != nil {
		return nil, err
	}

	// TODO: more optimal comparators for non-nullable columns
	switch schema.Columns[columnIndex].Type { 
	{% for t in env['TYPE_SUPPORT'] -%}
	case reflect.TypeOf({{ t['Zero'] }}):
		return createColumnSortFunc{{ t['Type'] }}(columnIndex, columnKey.Asc), nil
	{% endfor -%}
	default:
		return nil, errors.New("The data type is not supported, expecting a column of some supported primitive type")
	}
}

{% for t in env['TYPE_SUPPORT'] -%}
// {{ t['Raw'] }}

func createColumnSortFunc{{ t['Type'] }}(columnIndex int, asc bool) sortFuncExt {
	order := 1
	if !asc {
		order = -1
	}

	return func(r1 *Row, r2 *Row) int {
		return compareObservations{{ t['Type'] }}(r1.Values[columnIndex], r2.Values[columnIndex]) * order
	}
}

func compareObservations{{ t['Type'] }}(o1, o2 Observation) int {
	val1, notNull1 := o1.{{ t['Type'] }}()
	val2, notNull2 := o2.{{ t['Type'] }}()
	switch {
	case notNull1 && notNull2:
		return compare{{ t['Type'] }}(val1, val2)
	case notNull1 && !notNull2:
		return 1
	case !notNull1 && notNull2:
		return -1
	default:
		return 0
	}
}

{% if t['Raw'] not in env['CUSTOM_COMPARE'] %}
func compare{{ t['Type'] }}(val1, val2 {{ t['Raw'] }}) int {
	switch {
	case val1 < val2:
		return -1
	case val1 > val2:
		return 1
	default:
		return 0
	}
}
{% endif %}
{% endfor %}
'''

import jinja2
def write_tpl(tpl, name):
	template = jinja2.Template(tpl)
	with open(name, 'wb') as f:
		f.write(template.render(env=globals()))

if __name__ == "__main__":
	for (f, tpl) in TPL.iteritems():
		write_tpl(tpl, f)