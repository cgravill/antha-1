// Code generated by gen.py. DO NOT EDIT.
package data

import (
	"reflect"

	"github.com/pkg/errors"
)

func createColumnSortFunc(schema Schema, columnKey ColumnKey) (sortFuncExt, error) {
	columnIndex, err := schema.ColIndex(columnKey.Column)
	if err != nil {
		return nil, err
	}

	// TODO: more optimal comparators for non-nullable columns
	switch schema.Columns[columnIndex].Type { 
	case reflect.TypeOf(float64(0)):
		return createColumnSortFuncFloat64(columnIndex, columnKey.Asc), nil
	case reflect.TypeOf(int64(0)):
		return createColumnSortFuncInt64(columnIndex, columnKey.Asc), nil
	case reflect.TypeOf(""):
		return createColumnSortFuncString(columnIndex, columnKey.Asc), nil
	case reflect.TypeOf(false):
		return createColumnSortFuncBool(columnIndex, columnKey.Asc), nil
	default:
		return nil, errors.New("The data type is not supported, expecting a column of some supported primitive type")
	}
}

// float64

func createColumnSortFuncFloat64(columnIndex int, asc bool) sortFuncExt {
	order := 1
	if !asc {
		order = -1
	}

	return func(r1 *Row, r2 *Row) int {
		return compareObservationsFloat64(r1.Values[columnIndex], r2.Values[columnIndex]) * order
	}
}

func compareObservationsFloat64(o1, o2 Observation) int {
	val1, notNull1 := o1.Float64()
	val2, notNull2 := o2.Float64()
	switch {
	case notNull1 && notNull2:
		return compareFloat64(val1, val2)
	case notNull1 && !notNull2:
		return 1
	case !notNull1 && notNull2:
		return -1
	default:
		return 0
	}
}


func compareFloat64(val1, val2 float64) int {
	switch {
	case val1 < val2:
		return -1
	case val1 > val2:
		return 1
	default:
		return 0
	}
}

// int64

func createColumnSortFuncInt64(columnIndex int, asc bool) sortFuncExt {
	order := 1
	if !asc {
		order = -1
	}

	return func(r1 *Row, r2 *Row) int {
		return compareObservationsInt64(r1.Values[columnIndex], r2.Values[columnIndex]) * order
	}
}

func compareObservationsInt64(o1, o2 Observation) int {
	val1, notNull1 := o1.Int64()
	val2, notNull2 := o2.Int64()
	switch {
	case notNull1 && notNull2:
		return compareInt64(val1, val2)
	case notNull1 && !notNull2:
		return 1
	case !notNull1 && notNull2:
		return -1
	default:
		return 0
	}
}


func compareInt64(val1, val2 int64) int {
	switch {
	case val1 < val2:
		return -1
	case val1 > val2:
		return 1
	default:
		return 0
	}
}

// string

func createColumnSortFuncString(columnIndex int, asc bool) sortFuncExt {
	order := 1
	if !asc {
		order = -1
	}

	return func(r1 *Row, r2 *Row) int {
		return compareObservationsString(r1.Values[columnIndex], r2.Values[columnIndex]) * order
	}
}

func compareObservationsString(o1, o2 Observation) int {
	val1, notNull1 := o1.String()
	val2, notNull2 := o2.String()
	switch {
	case notNull1 && notNull2:
		return compareString(val1, val2)
	case notNull1 && !notNull2:
		return 1
	case !notNull1 && notNull2:
		return -1
	default:
		return 0
	}
}


// bool

func createColumnSortFuncBool(columnIndex int, asc bool) sortFuncExt {
	order := 1
	if !asc {
		order = -1
	}

	return func(r1 *Row, r2 *Row) int {
		return compareObservationsBool(r1.Values[columnIndex], r2.Values[columnIndex]) * order
	}
}

func compareObservationsBool(o1, o2 Observation) int {
	val1, notNull1 := o1.Bool()
	val2, notNull2 := o2.Bool()
	switch {
	case notNull1 && notNull2:
		return compareBool(val1, val2)
	case notNull1 && !notNull2:
		return 1
	case !notNull1 && notNull2:
		return -1
	default:
		return 0
	}
}


