// Code generated by gen.py. DO NOT EDIT.
package data

import (
	"reflect"

	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/memory"
	"github.com/pkg/errors"
)



// float64

func NewArrowSeriesFloat64(col ColumnName, values *array.Float64) *Series {
	metadata := &float64ArrowSeriesMeta{values: values}
	return &Series{
		typ:  reflect.TypeOf(float64(0)),
		col:  col,
		read: metadata.read,
		meta: metadata,
	}
}

func NewArrowSeriesFromSliceFloat64(col ColumnName, values []float64, mask []bool) *Series {
	builder := array.NewFloat64Builder(memory.DefaultAllocator)
	if len(values) > 0 {
		builder.AppendValues(values, mask)
	}
	arrowValues := builder.NewFloat64Array()
	return NewArrowSeriesFloat64(col, arrowValues)
}

func NewArrowSeriesFromSeriesFloat64(series *Series) (*Series, error) {
	if !series.meta.IsBounded() {
		return nil, errors.New("Unable to materialize unbounded series")
	}

	iterCache := &seriesIterCache{}
	iter := series.read(iterCache)

	typedIter, err := series.iterateFloat64(iter)
	if err != nil {
		return nil, err
	}

	builder := array.NewFloat64Builder(memory.DefaultAllocator)
	for typedIter.Next() {
		if value, ok := typedIter.Float64(); ok {
			builder.Append(value)
		} else {
			builder.AppendNull()
		}
	}
	arrowValues := builder.NewFloat64Array()
	return NewArrowSeriesFloat64(series.col, arrowValues), nil
}

func NewArrowSeriesFromRowsFloat64(rows *Rows, col ColumnName) (*Series, error) {
	builder := array.NewFloat64Builder(memory.DefaultAllocator)
	for i := range rows.Data {
		observation, err := rows.Data[i].Observation(col)
		if err != nil {
			return nil, err
		}

		if observation.value == nil {
			builder.AppendNull()
		} else if value, ok := observation.value.(float64); ok {
			builder.Append(value)
		} else {
			return nil, errors.Errorf("Observation value %v cannot be castede to float64", observation.value)
		}
	}
	arrowValues := builder.NewFloat64Array()
	return NewArrowSeriesFloat64(col, arrowValues), nil
}

type float64ArrowSeriesMeta struct {
	values *array.Float64
}

func (m *float64ArrowSeriesMeta) IsBounded() bool { return true; }
func (m *float64ArrowSeriesMeta) IsMaterialized() bool { return true; }

func (m *float64ArrowSeriesMeta) ExactSize() int {
	return m.values.Len()
}
func (m *float64ArrowSeriesMeta) MaxSize() int {
	return m.values.Len()
}

func (m *float64ArrowSeriesMeta) read(_ *seriesIterCache) iterator {
	return &float64ArrowSeriesIter{
		float64ArrowSeriesMeta: m,
		pos:                  -1,
	}
}

var _ Bounded = (*float64ArrowSeriesMeta)(nil)

type float64ArrowSeriesIter struct {
	*float64ArrowSeriesMeta
	pos int
}

func (i *float64ArrowSeriesIter) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *float64ArrowSeriesIter) Float64() (float64, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return float64(0), false
	}
}

func (i *float64ArrowSeriesIter) Value() interface{} {
	if val, ok := i.Float64(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*float64ArrowSeriesIter)(nil)
var _ iterFloat64 = (*float64ArrowSeriesIter)(nil)



// int64

func NewArrowSeriesInt64(col ColumnName, values *array.Int64) *Series {
	metadata := &int64ArrowSeriesMeta{values: values}
	return &Series{
		typ:  reflect.TypeOf(int64(0)),
		col:  col,
		read: metadata.read,
		meta: metadata,
	}
}

func NewArrowSeriesFromSliceInt64(col ColumnName, values []int64, mask []bool) *Series {
	builder := array.NewInt64Builder(memory.DefaultAllocator)
	if len(values) > 0 {
		builder.AppendValues(values, mask)
	}
	arrowValues := builder.NewInt64Array()
	return NewArrowSeriesInt64(col, arrowValues)
}

func NewArrowSeriesFromSeriesInt64(series *Series) (*Series, error) {
	if !series.meta.IsBounded() {
		return nil, errors.New("Unable to materialize unbounded series")
	}

	iterCache := &seriesIterCache{}
	iter := series.read(iterCache)

	typedIter, err := series.iterateInt64(iter)
	if err != nil {
		return nil, err
	}

	builder := array.NewInt64Builder(memory.DefaultAllocator)
	for typedIter.Next() {
		if value, ok := typedIter.Int64(); ok {
			builder.Append(value)
		} else {
			builder.AppendNull()
		}
	}
	arrowValues := builder.NewInt64Array()
	return NewArrowSeriesInt64(series.col, arrowValues), nil
}

func NewArrowSeriesFromRowsInt64(rows *Rows, col ColumnName) (*Series, error) {
	builder := array.NewInt64Builder(memory.DefaultAllocator)
	for i := range rows.Data {
		observation, err := rows.Data[i].Observation(col)
		if err != nil {
			return nil, err
		}

		if observation.value == nil {
			builder.AppendNull()
		} else if value, ok := observation.value.(int64); ok {
			builder.Append(value)
		} else {
			return nil, errors.Errorf("Observation value %v cannot be castede to int64", observation.value)
		}
	}
	arrowValues := builder.NewInt64Array()
	return NewArrowSeriesInt64(col, arrowValues), nil
}

type int64ArrowSeriesMeta struct {
	values *array.Int64
}

func (m *int64ArrowSeriesMeta) IsBounded() bool { return true; }
func (m *int64ArrowSeriesMeta) IsMaterialized() bool { return true; }

func (m *int64ArrowSeriesMeta) ExactSize() int {
	return m.values.Len()
}
func (m *int64ArrowSeriesMeta) MaxSize() int {
	return m.values.Len()
}

func (m *int64ArrowSeriesMeta) read(_ *seriesIterCache) iterator {
	return &int64ArrowSeriesIter{
		int64ArrowSeriesMeta: m,
		pos:                  -1,
	}
}

var _ Bounded = (*int64ArrowSeriesMeta)(nil)

type int64ArrowSeriesIter struct {
	*int64ArrowSeriesMeta
	pos int
}

func (i *int64ArrowSeriesIter) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *int64ArrowSeriesIter) Int64() (int64, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return int64(0), false
	}
}

func (i *int64ArrowSeriesIter) Value() interface{} {
	if val, ok := i.Int64(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*int64ArrowSeriesIter)(nil)
var _ iterInt64 = (*int64ArrowSeriesIter)(nil)



// string

func NewArrowSeriesString(col ColumnName, values *array.String) *Series {
	metadata := &stringArrowSeriesMeta{values: values}
	return &Series{
		typ:  reflect.TypeOf(""),
		col:  col,
		read: metadata.read,
		meta: metadata,
	}
}

func NewArrowSeriesFromSliceString(col ColumnName, values []string, mask []bool) *Series {
	builder := array.NewStringBuilder(memory.DefaultAllocator)
	if len(values) > 0 {
		builder.AppendValues(values, mask)
	}
	arrowValues := builder.NewStringArray()
	return NewArrowSeriesString(col, arrowValues)
}

func NewArrowSeriesFromSeriesString(series *Series) (*Series, error) {
	if !series.meta.IsBounded() {
		return nil, errors.New("Unable to materialize unbounded series")
	}

	iterCache := &seriesIterCache{}
	iter := series.read(iterCache)

	typedIter, err := series.iterateString(iter)
	if err != nil {
		return nil, err
	}

	builder := array.NewStringBuilder(memory.DefaultAllocator)
	for typedIter.Next() {
		if value, ok := typedIter.String(); ok {
			builder.Append(value)
		} else {
			builder.AppendNull()
		}
	}
	arrowValues := builder.NewStringArray()
	return NewArrowSeriesString(series.col, arrowValues), nil
}

func NewArrowSeriesFromRowsString(rows *Rows, col ColumnName) (*Series, error) {
	builder := array.NewStringBuilder(memory.DefaultAllocator)
	for i := range rows.Data {
		observation, err := rows.Data[i].Observation(col)
		if err != nil {
			return nil, err
		}

		if observation.value == nil {
			builder.AppendNull()
		} else if value, ok := observation.value.(string); ok {
			builder.Append(value)
		} else {
			return nil, errors.Errorf("Observation value %v cannot be castede to string", observation.value)
		}
	}
	arrowValues := builder.NewStringArray()
	return NewArrowSeriesString(col, arrowValues), nil
}

type stringArrowSeriesMeta struct {
	values *array.String
}

func (m *stringArrowSeriesMeta) IsBounded() bool { return true; }
func (m *stringArrowSeriesMeta) IsMaterialized() bool { return true; }

func (m *stringArrowSeriesMeta) ExactSize() int {
	return m.values.Len()
}
func (m *stringArrowSeriesMeta) MaxSize() int {
	return m.values.Len()
}

func (m *stringArrowSeriesMeta) read(_ *seriesIterCache) iterator {
	return &stringArrowSeriesIter{
		stringArrowSeriesMeta: m,
		pos:                  -1,
	}
}

var _ Bounded = (*stringArrowSeriesMeta)(nil)

type stringArrowSeriesIter struct {
	*stringArrowSeriesMeta
	pos int
}

func (i *stringArrowSeriesIter) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *stringArrowSeriesIter) String() (string, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return "", false
	}
}

func (i *stringArrowSeriesIter) Value() interface{} {
	if val, ok := i.String(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*stringArrowSeriesIter)(nil)
var _ iterString = (*stringArrowSeriesIter)(nil)



// bool

func NewArrowSeriesBool(col ColumnName, values *array.Boolean) *Series {
	metadata := &boolArrowSeriesMeta{values: values}
	return &Series{
		typ:  reflect.TypeOf(false),
		col:  col,
		read: metadata.read,
		meta: metadata,
	}
}

func NewArrowSeriesFromSliceBool(col ColumnName, values []bool, mask []bool) *Series {
	builder := array.NewBooleanBuilder(memory.DefaultAllocator)
	if len(values) > 0 {
		builder.AppendValues(values, mask)
	}
	arrowValues := builder.NewBooleanArray()
	return NewArrowSeriesBool(col, arrowValues)
}

func NewArrowSeriesFromSeriesBool(series *Series) (*Series, error) {
	if !series.meta.IsBounded() {
		return nil, errors.New("Unable to materialize unbounded series")
	}

	iterCache := &seriesIterCache{}
	iter := series.read(iterCache)

	typedIter, err := series.iterateBool(iter)
	if err != nil {
		return nil, err
	}

	builder := array.NewBooleanBuilder(memory.DefaultAllocator)
	for typedIter.Next() {
		if value, ok := typedIter.Bool(); ok {
			builder.Append(value)
		} else {
			builder.AppendNull()
		}
	}
	arrowValues := builder.NewBooleanArray()
	return NewArrowSeriesBool(series.col, arrowValues), nil
}

func NewArrowSeriesFromRowsBool(rows *Rows, col ColumnName) (*Series, error) {
	builder := array.NewBooleanBuilder(memory.DefaultAllocator)
	for i := range rows.Data {
		observation, err := rows.Data[i].Observation(col)
		if err != nil {
			return nil, err
		}

		if observation.value == nil {
			builder.AppendNull()
		} else if value, ok := observation.value.(bool); ok {
			builder.Append(value)
		} else {
			return nil, errors.Errorf("Observation value %v cannot be castede to bool", observation.value)
		}
	}
	arrowValues := builder.NewBooleanArray()
	return NewArrowSeriesBool(col, arrowValues), nil
}

type boolArrowSeriesMeta struct {
	values *array.Boolean
}

func (m *boolArrowSeriesMeta) IsBounded() bool { return true; }
func (m *boolArrowSeriesMeta) IsMaterialized() bool { return true; }

func (m *boolArrowSeriesMeta) ExactSize() int {
	return m.values.Len()
}
func (m *boolArrowSeriesMeta) MaxSize() int {
	return m.values.Len()
}

func (m *boolArrowSeriesMeta) read(_ *seriesIterCache) iterator {
	return &boolArrowSeriesIter{
		boolArrowSeriesMeta: m,
		pos:                  -1,
	}
}

var _ Bounded = (*boolArrowSeriesMeta)(nil)

type boolArrowSeriesIter struct {
	*boolArrowSeriesMeta
	pos int
}

func (i *boolArrowSeriesIter) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *boolArrowSeriesIter) Bool() (bool, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return false, false
	}
}

func (i *boolArrowSeriesIter) Value() interface{} {
	if val, ok := i.Bool(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*boolArrowSeriesIter)(nil)
var _ iterBool = (*boolArrowSeriesIter)(nil)

