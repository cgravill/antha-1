// Code generated by gen.py. DO NOT EDIT.
package data

import (
	"reflect"

	"github.com/apache/arrow/go/arrow/array"
	"github.com/apache/arrow/go/arrow/memory"
	"github.com/pkg/errors"
)

// Series implemented on the top of Apache Arrow.
// For now, designed in the same style as arrow/go library: i.e. no reflection, using generated code supporting a finite list of data types

// NewArrowSeriesBuilder creates a new builder for Arrow Series
func NewArrowSeriesBuilder(col ColumnName, typ reflect.Type) (MaterializedSeriesBuilder, error) {
	switch typ {
		case reflect.TypeOf(float64(0)):
			return newArrowSeriesBuilderFloat64(col), nil
		case reflect.TypeOf(int64(0)):
			return newArrowSeriesBuilderInt64(col), nil
		case reflect.TypeOf(""):
			return newArrowSeriesBuilderString(col), nil
		case reflect.TypeOf(false):
			return newArrowSeriesBuilderBool(col), nil
		default:
			return nil, errors.Errorf("The data type %v is not supported", typ)
	}
}

// NewArrowSeries converts an existing Arrow array to a new Series. Only closed list of Arrow data types is supported yet.
func NewArrowSeries(col ColumnName, values array.Interface) (*Series, error) {
	switch typedValues := values.(type) {
	case *array.Float64:
		return NewArrowSeriesFloat64(col, typedValues), nil
	case *array.Int64:
		return NewArrowSeriesInt64(col, typedValues), nil
	case *array.String:
		return NewArrowSeriesString(col, typedValues), nil
	case *array.Boolean:
		return NewArrowSeriesBool(col, typedValues), nil
	default:
		return nil, errors.Errorf("Arrow data type %v is not supported", values.DataType().ID())
	}
}

// NewArrowSeriesFromSlice converts a slice of scalars to a new (Arrow-based) Series
// mask denotes elements set to null; it is optional and can be set to nil
// Only a closed list of primitive data types is supported yet
func NewArrowSeriesFromSlice(col ColumnName, values interface{}, mask []bool) (*Series, error) {
	switch typedValues := values.(type) {
	case []float64:
		return NewArrowSeriesFromSliceFloat64(col, typedValues, mask), nil
	case []int64:
		return NewArrowSeriesFromSliceInt64(col, typedValues, mask), nil
	case []string:
		return NewArrowSeriesFromSliceString(col, typedValues, mask), nil
	case []bool:
		return NewArrowSeriesFromSliceBool(col, typedValues, mask), nil
	default:
		return nil, errors.Errorf("The data type %v is not supported, expecting slice of supported primitive types", reflect.TypeOf(values))
	}
}

// NewArrowSeriesFromSeries converts arbitrary Series into a new Arrow-based Series
func NewArrowSeriesFromSeries(series *Series) (*Series, error) {
	// for now, only series of supported Arrow types are supported
	switch series.typ {
	case reflect.TypeOf(float64(0)):
		return NewArrowSeriesFromSeriesFloat64(series)
	case reflect.TypeOf(int64(0)):
		return NewArrowSeriesFromSeriesInt64(series)
	case reflect.TypeOf(""):
		return NewArrowSeriesFromSeriesString(series)
	case reflect.TypeOf(false):
		return NewArrowSeriesFromSeriesBool(series)
	default:
		return nil, errors.New("The data type is not supported, expecting a series of supported primitive type")
	}
}

// NewArrowSeriesFromRows converts a column of a Row-wide representation of a table into a new Arrow-based Series
func NewArrowSeriesFromRows(rows *Rows, col ColumnName) (*Series, error) {
	column, err := rows.Schema.Col(col)
	if err != nil {
		return nil, err
	}

	// for now, only columns of supported Arrow types are supported
	switch column.Type {
	case reflect.TypeOf(float64(0)):
		return NewArrowSeriesFromRowsFloat64(rows, col)
	case reflect.TypeOf(int64(0)):
		return NewArrowSeriesFromRowsInt64(rows, col)
	case reflect.TypeOf(""):
		return NewArrowSeriesFromRowsString(rows, col)
	case reflect.TypeOf(false):
		return NewArrowSeriesFromRowsBool(rows, col)
	default:
		return nil, errors.New("The data type is not supported, expecting rows of supported primitive type")
	}
}

// float64

type arrowSeriesBuilderFloat64 struct {
	builder *array.Float64Builder
	col ColumnName
}

func newArrowSeriesBuilderFloat64(col ColumnName) *arrowSeriesBuilderFloat64 {
	return &arrowSeriesBuilderFloat64 {
		builder: array.NewFloat64Builder(memory.DefaultAllocator),
		col:     col,
	}
}

func (b* arrowSeriesBuilderFloat64) Reserve(capacity int)     { b.builder.Reserve(capacity) }
func (b* arrowSeriesBuilderFloat64) Size() int                { return b.builder.Len() }
func (b* arrowSeriesBuilderFloat64) Append(value interface{}) { b.builder.Append(value.(float64)) }
func (b* arrowSeriesBuilderFloat64) AppendNull()              { b.builder.AppendNull() }
func (b* arrowSeriesBuilderFloat64) Build() *Series           { return NewArrowSeriesFloat64(b.col, b.builder.NewFloat64Array()) }

var _ MaterializedSeriesBuilder = (*arrowSeriesBuilderFloat64)(nil)

func NewArrowSeriesFloat64(col ColumnName, values *array.Float64) *Series {
	metadata := &arrowSeriesMeta{values: values}
	return &Series{
		typ:  reflect.TypeOf(float64(0)),
		col:  col,
		read: metadata.readFloat64,
		meta: metadata,
	}
}

func NewArrowSeriesFromSliceFloat64(col ColumnName, values []float64, mask []bool) *Series {
	builder := array.NewFloat64Builder(memory.DefaultAllocator)
	if len(values) > 0 {
		builder.AppendValues(values, mask)
	}
	arrowValues := builder.NewFloat64Array()
	return NewArrowSeriesFloat64(col, arrowValues)
}

func NewArrowSeriesFromSeriesFloat64(series *Series) (*Series, error) {
	if !series.meta.IsBounded() {
		return nil, errors.New("Unable to materialize unbounded series")
	}

	iterCache := &seriesIterCache{}
	iter := series.read(iterCache)

	typedIter, err := series.iterateFloat64(iter)
	if err != nil {
		return nil, err
	}

	builder := array.NewFloat64Builder(memory.DefaultAllocator)
	for typedIter.Next() {
		if value, ok := typedIter.Float64(); ok {
			builder.Append(value)
		} else {
			builder.AppendNull()
		}
	}
	arrowValues := builder.NewFloat64Array()
	return NewArrowSeriesFloat64(series.col, arrowValues), nil
}

func NewArrowSeriesFromRowsFloat64(rows *Rows, col ColumnName) (*Series, error) {
	builder := array.NewFloat64Builder(memory.DefaultAllocator)
	for i := range rows.Data {
		observation, err := rows.Data[i].Observation(col)
		if err != nil {
			return nil, err
		}

		if observation.value == nil {
			builder.AppendNull()
		} else if value, ok := observation.value.(float64); ok {
			builder.Append(value)
		} else {
			return nil, errors.Errorf("Observation value %v cannot be castede to float64", observation.value)
		}
	}
	arrowValues := builder.NewFloat64Array()
	return NewArrowSeriesFloat64(col, arrowValues), nil
}

func (m *arrowSeriesMeta) readFloat64(_ *seriesIterCache) iterator {
	return &arrowSeriesIterFloat64{
		values: m.values.(*array.Float64),
		pos:    -1,
	}
}

type arrowSeriesIterFloat64 struct {
	values *array.Float64
	pos int
}

func (i *arrowSeriesIterFloat64) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *arrowSeriesIterFloat64) Float64() (float64, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return float64(0), false
	}
}

func (i *arrowSeriesIterFloat64) Value() interface{} {
	if val, ok := i.Float64(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*arrowSeriesIterFloat64)(nil)
var _ iterFloat64 = (*arrowSeriesIterFloat64)(nil)

// int64

type arrowSeriesBuilderInt64 struct {
	builder *array.Int64Builder
	col ColumnName
}

func newArrowSeriesBuilderInt64(col ColumnName) *arrowSeriesBuilderInt64 {
	return &arrowSeriesBuilderInt64 {
		builder: array.NewInt64Builder(memory.DefaultAllocator),
		col:     col,
	}
}

func (b* arrowSeriesBuilderInt64) Reserve(capacity int)     { b.builder.Reserve(capacity) }
func (b* arrowSeriesBuilderInt64) Size() int                { return b.builder.Len() }
func (b* arrowSeriesBuilderInt64) Append(value interface{}) { b.builder.Append(value.(int64)) }
func (b* arrowSeriesBuilderInt64) AppendNull()              { b.builder.AppendNull() }
func (b* arrowSeriesBuilderInt64) Build() *Series           { return NewArrowSeriesInt64(b.col, b.builder.NewInt64Array()) }

var _ MaterializedSeriesBuilder = (*arrowSeriesBuilderInt64)(nil)

func NewArrowSeriesInt64(col ColumnName, values *array.Int64) *Series {
	metadata := &arrowSeriesMeta{values: values}
	return &Series{
		typ:  reflect.TypeOf(int64(0)),
		col:  col,
		read: metadata.readInt64,
		meta: metadata,
	}
}

func NewArrowSeriesFromSliceInt64(col ColumnName, values []int64, mask []bool) *Series {
	builder := array.NewInt64Builder(memory.DefaultAllocator)
	if len(values) > 0 {
		builder.AppendValues(values, mask)
	}
	arrowValues := builder.NewInt64Array()
	return NewArrowSeriesInt64(col, arrowValues)
}

func NewArrowSeriesFromSeriesInt64(series *Series) (*Series, error) {
	if !series.meta.IsBounded() {
		return nil, errors.New("Unable to materialize unbounded series")
	}

	iterCache := &seriesIterCache{}
	iter := series.read(iterCache)

	typedIter, err := series.iterateInt64(iter)
	if err != nil {
		return nil, err
	}

	builder := array.NewInt64Builder(memory.DefaultAllocator)
	for typedIter.Next() {
		if value, ok := typedIter.Int64(); ok {
			builder.Append(value)
		} else {
			builder.AppendNull()
		}
	}
	arrowValues := builder.NewInt64Array()
	return NewArrowSeriesInt64(series.col, arrowValues), nil
}

func NewArrowSeriesFromRowsInt64(rows *Rows, col ColumnName) (*Series, error) {
	builder := array.NewInt64Builder(memory.DefaultAllocator)
	for i := range rows.Data {
		observation, err := rows.Data[i].Observation(col)
		if err != nil {
			return nil, err
		}

		if observation.value == nil {
			builder.AppendNull()
		} else if value, ok := observation.value.(int64); ok {
			builder.Append(value)
		} else {
			return nil, errors.Errorf("Observation value %v cannot be castede to int64", observation.value)
		}
	}
	arrowValues := builder.NewInt64Array()
	return NewArrowSeriesInt64(col, arrowValues), nil
}

func (m *arrowSeriesMeta) readInt64(_ *seriesIterCache) iterator {
	return &arrowSeriesIterInt64{
		values: m.values.(*array.Int64),
		pos:    -1,
	}
}

type arrowSeriesIterInt64 struct {
	values *array.Int64
	pos int
}

func (i *arrowSeriesIterInt64) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *arrowSeriesIterInt64) Int64() (int64, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return int64(0), false
	}
}

func (i *arrowSeriesIterInt64) Value() interface{} {
	if val, ok := i.Int64(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*arrowSeriesIterInt64)(nil)
var _ iterInt64 = (*arrowSeriesIterInt64)(nil)

// string

type arrowSeriesBuilderString struct {
	builder *array.StringBuilder
	col ColumnName
}

func newArrowSeriesBuilderString(col ColumnName) *arrowSeriesBuilderString {
	return &arrowSeriesBuilderString {
		builder: array.NewStringBuilder(memory.DefaultAllocator),
		col:     col,
	}
}

func (b* arrowSeriesBuilderString) Reserve(capacity int)     { b.builder.Reserve(capacity) }
func (b* arrowSeriesBuilderString) Size() int                { return b.builder.Len() }
func (b* arrowSeriesBuilderString) Append(value interface{}) { b.builder.Append(value.(string)) }
func (b* arrowSeriesBuilderString) AppendNull()              { b.builder.AppendNull() }
func (b* arrowSeriesBuilderString) Build() *Series           { return NewArrowSeriesString(b.col, b.builder.NewStringArray()) }

var _ MaterializedSeriesBuilder = (*arrowSeriesBuilderString)(nil)

func NewArrowSeriesString(col ColumnName, values *array.String) *Series {
	metadata := &arrowSeriesMeta{values: values}
	return &Series{
		typ:  reflect.TypeOf(""),
		col:  col,
		read: metadata.readString,
		meta: metadata,
	}
}

func NewArrowSeriesFromSliceString(col ColumnName, values []string, mask []bool) *Series {
	builder := array.NewStringBuilder(memory.DefaultAllocator)
	if len(values) > 0 {
		builder.AppendValues(values, mask)
	}
	arrowValues := builder.NewStringArray()
	return NewArrowSeriesString(col, arrowValues)
}

func NewArrowSeriesFromSeriesString(series *Series) (*Series, error) {
	if !series.meta.IsBounded() {
		return nil, errors.New("Unable to materialize unbounded series")
	}

	iterCache := &seriesIterCache{}
	iter := series.read(iterCache)

	typedIter, err := series.iterateString(iter)
	if err != nil {
		return nil, err
	}

	builder := array.NewStringBuilder(memory.DefaultAllocator)
	for typedIter.Next() {
		if value, ok := typedIter.String(); ok {
			builder.Append(value)
		} else {
			builder.AppendNull()
		}
	}
	arrowValues := builder.NewStringArray()
	return NewArrowSeriesString(series.col, arrowValues), nil
}

func NewArrowSeriesFromRowsString(rows *Rows, col ColumnName) (*Series, error) {
	builder := array.NewStringBuilder(memory.DefaultAllocator)
	for i := range rows.Data {
		observation, err := rows.Data[i].Observation(col)
		if err != nil {
			return nil, err
		}

		if observation.value == nil {
			builder.AppendNull()
		} else if value, ok := observation.value.(string); ok {
			builder.Append(value)
		} else {
			return nil, errors.Errorf("Observation value %v cannot be castede to string", observation.value)
		}
	}
	arrowValues := builder.NewStringArray()
	return NewArrowSeriesString(col, arrowValues), nil
}

func (m *arrowSeriesMeta) readString(_ *seriesIterCache) iterator {
	return &arrowSeriesIterString{
		values: m.values.(*array.String),
		pos:    -1,
	}
}

type arrowSeriesIterString struct {
	values *array.String
	pos int
}

func (i *arrowSeriesIterString) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *arrowSeriesIterString) String() (string, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return "", false
	}
}

func (i *arrowSeriesIterString) Value() interface{} {
	if val, ok := i.String(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*arrowSeriesIterString)(nil)
var _ iterString = (*arrowSeriesIterString)(nil)

// bool

type arrowSeriesBuilderBool struct {
	builder *array.BooleanBuilder
	col ColumnName
}

func newArrowSeriesBuilderBool(col ColumnName) *arrowSeriesBuilderBool {
	return &arrowSeriesBuilderBool {
		builder: array.NewBooleanBuilder(memory.DefaultAllocator),
		col:     col,
	}
}

func (b* arrowSeriesBuilderBool) Reserve(capacity int)     { b.builder.Reserve(capacity) }
func (b* arrowSeriesBuilderBool) Size() int                { return b.builder.Len() }
func (b* arrowSeriesBuilderBool) Append(value interface{}) { b.builder.Append(value.(bool)) }
func (b* arrowSeriesBuilderBool) AppendNull()              { b.builder.AppendNull() }
func (b* arrowSeriesBuilderBool) Build() *Series           { return NewArrowSeriesBool(b.col, b.builder.NewBooleanArray()) }

var _ MaterializedSeriesBuilder = (*arrowSeriesBuilderBool)(nil)

func NewArrowSeriesBool(col ColumnName, values *array.Boolean) *Series {
	metadata := &arrowSeriesMeta{values: values}
	return &Series{
		typ:  reflect.TypeOf(false),
		col:  col,
		read: metadata.readBool,
		meta: metadata,
	}
}

func NewArrowSeriesFromSliceBool(col ColumnName, values []bool, mask []bool) *Series {
	builder := array.NewBooleanBuilder(memory.DefaultAllocator)
	if len(values) > 0 {
		builder.AppendValues(values, mask)
	}
	arrowValues := builder.NewBooleanArray()
	return NewArrowSeriesBool(col, arrowValues)
}

func NewArrowSeriesFromSeriesBool(series *Series) (*Series, error) {
	if !series.meta.IsBounded() {
		return nil, errors.New("Unable to materialize unbounded series")
	}

	iterCache := &seriesIterCache{}
	iter := series.read(iterCache)

	typedIter, err := series.iterateBool(iter)
	if err != nil {
		return nil, err
	}

	builder := array.NewBooleanBuilder(memory.DefaultAllocator)
	for typedIter.Next() {
		if value, ok := typedIter.Bool(); ok {
			builder.Append(value)
		} else {
			builder.AppendNull()
		}
	}
	arrowValues := builder.NewBooleanArray()
	return NewArrowSeriesBool(series.col, arrowValues), nil
}

func NewArrowSeriesFromRowsBool(rows *Rows, col ColumnName) (*Series, error) {
	builder := array.NewBooleanBuilder(memory.DefaultAllocator)
	for i := range rows.Data {
		observation, err := rows.Data[i].Observation(col)
		if err != nil {
			return nil, err
		}

		if observation.value == nil {
			builder.AppendNull()
		} else if value, ok := observation.value.(bool); ok {
			builder.Append(value)
		} else {
			return nil, errors.Errorf("Observation value %v cannot be castede to bool", observation.value)
		}
	}
	arrowValues := builder.NewBooleanArray()
	return NewArrowSeriesBool(col, arrowValues), nil
}

func (m *arrowSeriesMeta) readBool(_ *seriesIterCache) iterator {
	return &arrowSeriesIterBool{
		values: m.values.(*array.Boolean),
		pos:    -1,
	}
}

type arrowSeriesIterBool struct {
	values *array.Boolean
	pos int
}

func (i *arrowSeriesIterBool) Next() bool {
	i.pos++
	return i.pos < i.values.Len()
}

func (i *arrowSeriesIterBool) Bool() (bool, bool) {
	if !i.values.IsNull(i.pos) {
		return i.values.Value(i.pos), true
	} else {
		return false, false
	}
}

func (i *arrowSeriesIterBool) Value() interface{} {
	if val, ok := i.Bool(); ok {
		return val
	} else {
		return nil
	}
}

var _ iterator = (*arrowSeriesIterBool)(nil)
var _ iterBool = (*arrowSeriesIterBool)(nil)

