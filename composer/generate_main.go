package composer

import (
	"fmt"
	"io"
	"strings"
	"text/template"
	"unicode"

	"github.com/PaesslerAG/jsonpath"
)

type mainRenderer struct {
	composer *Composer
	varCount uint64
	varMemo  map[ElementInstanceName]string

	liquidNames map[string]struct{}
	plateNames  map[string]struct{}
	tipBoxNames map[string]struct{}
}

func newMainRenderer(c *Composer) *mainRenderer {
	return &mainRenderer{
		composer:    c,
		varMemo:     make(map[ElementInstanceName]string),
		liquidNames: make(map[string]struct{}),
		plateNames:  make(map[string]struct{}),
		tipBoxNames: make(map[string]struct{}),
	}
}

func (mr *mainRenderer) render(w io.Writer) error {
	fmt.Println(mr.ExtractComponents(), mr.liquidNames, mr.plateNames, mr.tipBoxNames)
	funcs := template.FuncMap{
		"elementTypes": mr.elementTypes,
		"varName":      mr.varName,
		"token":        mr.token,
	}
	if t, err := template.New("main").Funcs(funcs).Parse(tpl); err != nil {
		return err
	} else {
		return t.Execute(w, mr.composer.Workflow)
	}
}

func (mr *mainRenderer) ExtractComponents() error {
	types := map[string]map[string]struct{}{
		"wtype.Liquid":   mr.liquidNames,
		"wtype.Plate":    mr.plateNames,
		"wtype.LHTipbox": mr.tipBoxNames,
	}

	for instanceName, ei := range mr.composer.Workflow.ElementInstances {
		if et := mr.composer.elementTypes[ei.ElementTypeName]; et.IsAnthaElement() {
			if ps, err := mr.composer.Workflow.ElementInstancesParameters[instanceName].AsJSONInterface(); err != nil {
				return err
			} else {
				for _, msg := range et.transpiler.Messages {
					if msg.Name == "Inputs" || msg.Name == "Parameters" {
						jsonPathsMap := msg.JSONPathsPerType()
						for t, m := range types {
							for _, path := range jsonPathsMap[t] {
								if res, err := jsonpath.Get(path, ps); err != nil {
									return err
								} else {
									jsonPathResultsToStrings(m, res)
								}
							}
						}
					}
				}
			}
		}
	}
	return nil
}

func jsonPathResultsToStrings(acc map[string]struct{}, i interface{}) {
	// we only ever expect a string or a []interface
	switch i := i.(type) {
	case string:
		acc[i] = struct{}{}
	case []interface{}:
		for _, j := range i {
			jsonPathResultsToStrings(acc, j)
		}
	default:
		panic(fmt.Sprintf("Unexpected type: %T", i))
	}
}

func (mr *mainRenderer) varName(name ElementInstanceName) string {
	if res, found := mr.varMemo[name]; found {
		return res
	}

	res := make([]rune, 0, len(name))
	ensureUpper := false
	for _, r := range []rune(name) {
		switch {
		case 'a' <= r && r <= 'z' && ensureUpper:
			ensureUpper = false
			res = append(res, unicode.ToUpper(r))
		case 'a' <= r && r <= 'z':
			res = append(res, r)
		case 'A' <= r && r <= 'Z' && len(res) == 0:
			res = append(res, unicode.ToLower(r))
		case 'A' <= r && r <= 'Z':
			res = append(res, r)
			ensureUpper = false
		case strings.ContainsRune(" -_", r):
			ensureUpper = true
		}
	}
	resStr := fmt.Sprintf("%s%d", string(res), mr.varCount)
	mr.varCount++
	mr.varMemo[name] = resStr
	return resStr
}

func (mr *mainRenderer) elementTypes() map[ElementTypeName]*ElementType {
	return mr.composer.elementTypes
}

func (mr *mainRenderer) token(elem ElementInstanceName, param ElementParameterName) string {
	if elemInstance, found := mr.composer.Workflow.ElementInstances[elem]; !found {
		return ""
	} else if elemType, found := mr.composer.elementTypes[elemInstance.ElementTypeName]; !found {
		return ""
	} else if elemType.transpiler == nil {
		return ""
	} else if tok, found := elemType.transpiler.TokenByParamName[string(param)]; !found {
		return ""
	} else {
		return tok.String()
	}
}

var tpl = `// Code generated by antha composer. DO NOT EDIT.
package main

import (
	"encoding/json"

	"github.com/antha-lang/antha/laboratory"

{{range elementTypes}}{{if .IsAnthaElement}}	{{printf "%q" .ImportPath}}
{{end}}{{end}})

func main() {
	labBuild := laboratory.NewLaboratoryBuilder({{printf "%q" .JobId}})
	// Register line maps for the elements we're using
{{range elementTypes}}{{if .IsAnthaElement}}	{{.Name}}.RegisterLineMap(labBuild)
{{end}}{{end}}
	// Create the elements
{{range $name, $type := .ElementInstances}}	{{varName $name}} := {{$type.ElementTypeName}}.New{{$type.ElementTypeName}}(labBuild, {{printf "%q" $name}})
{{end}}
	// Add wiring
{{range .ElementInstancesConnections}}	labBuild.AddLink({{varName .Source.ElementInstance}}, {{varName .Target.ElementInstance}}, func () { {{varName .Target.ElementInstance}}.{{token .Target.ElementInstance .Target.ParameterName}}.{{.Target.ParameterName}} = {{varName .Source.ElementInstance}}.{{token .Source.ElementInstance .Source.ParameterName}}.{{.Source.ParameterName}} })
{{end}}
	// Set parameters
{{range $name, $params := .ElementInstancesParameters}}{{range $param, $value := $params}}	if err := json.Unmarshal([]byte({{printf "%q" $value}}), &{{varName $name}}.{{token $name $param}}.{{$param}}); err != nil {
		labBuild.Fatal(err)
	}
{{end}}{{end}}
	// Run!
	errRun := labBuild.RunElements()
	errSave := labBuild.Save()
	if errRun != nil {
		labBuild.Fatal(errRun)
	}
	if errSave != nil {
		labBuild.Fatal(errSave)
	}
}
`
